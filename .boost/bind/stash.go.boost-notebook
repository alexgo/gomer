{
  "cells": [
    {
      "outputs": [],
      "languageId": "go",
      "id": "0",
      "value": "package bind\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\t\"strings\"\n\n\t\"github.com/jt0/gomer/gomerr\"\n\t\"github.com/jt0/gomer/structs\"\n)\n\nfunc RegisterStashFieldFunction(name, sourceKey string, include InclusionPredicate) {\n\t_ = structs.RegisterToolFunction(\"$_stash.\"+name, func(sv reflect.Value, _ reflect.Value, tc *structs.ToolContext) (interface{}, gomerr.Gomerr) {\n\t\tstashData := tc.Get(sourceKey)\n\t\tif stashData == nil {\n\t\t\treturn nil, nil\n\t\t}\n\n\t\tsdv := reflect.ValueOf(stashData)\n\t\t// TODO:p3 sources other than maps, such as a struct or slice.\n\t\tif sdv.Kind() != reflect.Map {\n\t\t\treturn nil, gomerr.Unprocessable(\"Expected data map\", sdv.Type().String())\n\t\t}\n\n\t\tout := make(map[string]interface{})\n\t\titer := sdv.MapRange()\n\t\tfor iter.Next() { // TODO:p1 should only be from tc or can be from struct?\n\t\t\tkey := iter.Key().String()\n\t\t\tif include(key, iter.Value(), sv) {\n\t\t\t\tout[key] = iter.Value().Interface()\n\t\t\t}\n\t\t}\n\t\treturn out, nil\n\t})\n}\n",
      "kind": 2,
      "metadata": {
        "id": 0,
        "type": "originalCode",
        "lineNumberBase": 0
      }
    },
    {
      "outputs": [],
      "languageId": "go",
      "id": "1",
      "value": "\nfunc RegisterUnstashFieldFunction(name, destinationKey string, include InclusionPredicate, createIntermediates bool) {\n\t_ = structs.RegisterToolFunction(\"$_unstash.\"+name, func(sv reflect.Value, fv reflect.Value, tc *structs.ToolContext) (interface{}, gomerr.Gomerr) {\n\t\tif !fv.IsValid() {\n\t\t\treturn nil, nil // TODO: return an error?\n\t\t} // TODO:p3 handle fv as a ptr type\n\n\t\tdestination, ok := tc.Descend(destinationKey, createIntermediates)\n\t\tif !ok {\n\t\t\treturn nil, nil\n\t\t}\n\n\t\t// TODO:p3 destinations to types other than maps, such as a struct or slice.\n\t\titer := fv.MapRange()\n\t\tfor iter.Next() {\n\t\t\t// TODO:p1 We need a way to encode names that have a '.' in them, since that's the delimiter we use for\n\t\t\t//         describing a path and location.\n\t\t\tkey := iter.Key().String()\n\t\t\tstashValue := iter.Value()\n\t\t\tstashValueType := stashValue.Type()\n\t\t\tswitch stashValueType.Kind() {\n\t\t\tcase reflect.Struct:\n\t\t\t\titemDestination, itemOk := destination.Descend(key, createIntermediates)\n\t\t\t\tif !itemOk {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tfor i := 0; i < stashValueType.NumField(); i++ {\n\t\t\t\t\ttf := stashValueType.Field(i)\n\t\t\t\t\tvf := stashValue.Field(i)\n\t\t\t\t\tif include(tf.Name, vf, stashValue) {\n\t\t\t\t\t\t// m := make(map[string]interface{})\n\t\t\t\t\t\t// for\n\t\t\t\t\t\titemDestination.Put(tf.Name, vf.Interface())\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tcase reflect.Map:\n\t\t\t\tfmt.Printf(\"Unstash map not yet supported. Key = %s, Value =\\n%v\\n\", key, stashValue.Interface())\n\t\t\tcase reflect.Slice, reflect.Array:\n\t\t\t\tfmt.Printf(\"Unstash slice/array not yet supported. Key = %s, Value =\\n%v\\n\", key, stashValue.Interface())\n\t\t\tcase reflect.Ptr:\n\t\t\t\tfmt.Printf(\"Unstash pointer not yet supported. Key = %s, Value =\\n%v\", key, stashValue.Elem().Interface())\n\t\t\tdefault:\n\t\t\t\tdestination.Put(key, stashValue.Interface())\n\t\t\t}\n\t\t}\n\n\t\treturn nil, nil\n\t})\n}\n",
      "kind": 2,
      "metadata": {
        "id": 1,
        "type": "originalCode",
        "lineNumberBase": 35
      }
    },
    {
      "outputs": [],
      "languageId": "go",
      "id": "2",
      "value": "\n// InclusionPredicate and helper functions\n\ntype InclusionPredicate func(key string, value interface{}, sv reflect.Value) bool\n",
      "kind": 2,
      "metadata": {
        "id": 2,
        "type": "originalCode",
        "lineNumberBase": 84
      }
    },
    {
      "outputs": [],
      "languageId": "go",
      "id": "3",
      "value": "\nfunc IsField(key string, _ interface{}, sv reflect.Value) bool {\n\treturn sv.FieldByName(strings.Title(key)).IsValid()\n}\n",
      "kind": 2,
      "metadata": {
        "id": 3,
        "type": "originalCode",
        "lineNumberBase": 88
      }
    },
    {
      "outputs": [],
      "languageId": "go",
      "id": "4",
      "value": "\nfunc IsNotField(key string, _ interface{}, sv reflect.Value) bool {\n\treturn !sv.FieldByName(strings.Title(key)).IsValid()\n}\n",
      "kind": 2,
      "metadata": {
        "id": 4,
        "type": "originalCode",
        "lineNumberBase": 92
      }
    },
    {
      "outputs": [],
      "languageId": "go",
      "id": "5",
      "value": "\nfunc All(_ string, _ interface{}, _ reflect.Value) bool {\n\treturn true\n}\n",
      "kind": 2,
      "metadata": {
        "id": 5,
        "type": "originalCode",
        "lineNumberBase": 96
      }
    },
    {
      "outputs": [],
      "languageId": "go",
      "id": "6",
      "value": "\nfunc NameMatches(names ...string) InclusionPredicate {\n\tnm := make(map[string]bool, len(names))\n\tfor _, name := range names {\n\t\tnm[name] = true\n\t}\n\treturn func(key string, _ interface{}, _ reflect.Value) bool {\n\t\treturn nm[key]\n\t}\n}\n",
      "kind": 2,
      "metadata": {
        "id": 6,
        "type": "originalCode",
        "lineNumberBase": 100
      }
    },
    {
      "outputs": [],
      "languageId": "go",
      "id": "7",
      "value": "\nfunc IfAll(predicates ...InclusionPredicate) InclusionPredicate {\n\treturn func(key string, value interface{}, sv reflect.Value) bool {\n\t\tfor _, p := range predicates {\n\t\t\tif !p(key, value, sv) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n}\n",
      "kind": 2,
      "metadata": {
        "id": 7,
        "type": "originalCode",
        "lineNumberBase": 110
      }
    },
    {
      "outputs": [],
      "languageId": "go",
      "id": "8",
      "value": "\nfunc IfAny(predicates ...InclusionPredicate) InclusionPredicate {\n\treturn func(key string, value interface{}, sv reflect.Value) bool {\n\t\tfor _, p := range predicates {\n\t\t\tif p(key, value, sv) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\treturn false\n\t}\n}\n",
      "kind": 2,
      "metadata": {
        "id": 8,
        "type": "originalCode",
        "lineNumberBase": 121
      }
    },
    {
      "outputs": [],
      "languageId": "go",
      "id": "9",
      "value": "\n// UnstashConflictResolver and helper functions\n\ntype UnstashConflictResolver func(stashed, destination interface{}) interface{}\n",
      "kind": 2,
      "metadata": {
        "id": 9,
        "type": "originalCode",
        "lineNumberBase": 132
      }
    },
    {
      "outputs": [],
      "languageId": "go",
      "id": "10",
      "value": "\nfunc UseStashed(stashed, _ interface{}) interface{} {\n\treturn stashed\n}\n",
      "kind": 2,
      "metadata": {
        "id": 10,
        "type": "originalCode",
        "lineNumberBase": 136
      }
    },
    {
      "outputs": [],
      "languageId": "go",
      "id": "11",
      "value": "\n// func UseDestination(_, destination interface{}) interface{} {\n// \treturn destination\n// }\n",
      "kind": 2,
      "metadata": {
        "id": 11,
        "type": "originalCode",
        "lineNumberBase": 140
      }
    },
    {
      "outputs": [],
      "languageId": "go",
      "id": "12",
      "value": "\n// type MergeType int\n// const (\n// \tStashed MergeType = 1 << iota\n// \tDestination\n// \tSelect\n// \t// Combine // based on type. Examples: 1 combine 2 -> 3; \"1\" combine \"2\" -> \"12\"\n// \t// LogDropped\n// )\n\n// TODO: needs to be merged into unstash function above and drop\n\nfunc MergeStashed(include InclusionPredicate) UnstashConflictResolver {\n\t// TODO: revisit name; revisit resolver options\n\treturn func(stashed, destination interface{}) interface{} {\n\n\t\treturn nil // FIXME: dummy val\n\t}\n}\n",
      "kind": 2,
      "metadata": {
        "id": 12,
        "type": "originalCode",
        "lineNumberBase": 144
      }
    },
    {
      "outputs": [],
      "languageId": "go",
      "id": "13",
      "value": "\n// func MergeSlice(mergeType MergeType) UnstashConflictResolver {\n// }\n",
      "kind": 2,
      "metadata": {
        "id": 13,
        "type": "originalCode",
        "lineNumberBase": 163
      }
    }
  ],
  "metadata": {
    "defaultDir": ".boost",
    "sourceFile": "./bind/stash.go"
  }
}