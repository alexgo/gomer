{
  "cells": [
    {
      "outputs": [],
      "languageId": "go",
      "id": "0",
      "value": "package bind\n\nimport (\n\t\"reflect\"\n\t\"time\"\n\n\t\"github.com/jt0/gomer/flect\"\n\t\"github.com/jt0/gomer/gomerr\"\n\t\"github.com/jt0/gomer/structs\"\n)\n\nvar DefaultInTool = NewInTool(NewConfiguration(), structs.StructTagDirectiveProvider{\"in\"})\n",
      "kind": 2,
      "metadata": {
        "id": 0,
        "type": "originalCode",
        "lineNumberBase": 0
      }
    },
    {
      "outputs": [],
      "languageId": "go",
      "id": "1",
      "value": "\nfunc In(data map[string]interface{}, v interface{}, inTool *structs.Tool, optional ...*structs.ToolContext) gomerr.Gomerr {\n\treturn structs.ApplyTools(v, structs.EnsureContext(optional...).Put(InKey, data), inTool)\n}\n",
      "kind": 2,
      "metadata": {
        "id": 1,
        "type": "originalCode",
        "lineNumberBase": 12
      }
    },
    {
      "outputs": [],
      "languageId": "go",
      "id": "2",
      "value": "\n// NewInTool\n//\n// <name>              -> Default input value matching <name>. If name == \"\" then name = b.DataCase(StructField.Name)\n// =<static>           -> Application-defined static value\n// $<function>         -> Application-defined dynamic value\n// ?<directive>        -> Applied iff field.IsZero(). Supports chaining (e.g. \"query.aName?header.A-Source?=aDefault\")\n// <directive>&<right> -> Applies the left directive followed by the right (e.g. \"input&$transform)\n// -                   -> Explicitly not bound from any input\nfunc NewInTool(bindConfig Configuration, dp structs.DirectiveProvider) *structs.Tool {\n\tvar toolName = \"bind.InTool\"\n\tif bindConfig.extension != nil {\n\t\ttoolName = bindConfig.extension.Type()\n\t}\n\n\tvar tool structs.Tool\n\ttool = *structs.NewTool(toolName, inApplierProvider{bindConfig, &tool}, dp)\n\treturn &tool\n}\n",
      "kind": 2,
      "metadata": {
        "id": 2,
        "type": "originalCode",
        "lineNumberBase": 16
      }
    },
    {
      "outputs": [],
      "languageId": "go",
      "id": "3",
      "value": "\ntype inApplierProvider struct {\n\tConfiguration\n\ttool *structs.Tool\n}\n",
      "kind": 2,
      "metadata": {
        "id": 3,
        "type": "originalCode",
        "lineNumberBase": 35
      }
    },
    {
      "outputs": [],
      "languageId": "go",
      "id": "4",
      "value": "\nfunc (ap inApplierProvider) Applier(st reflect.Type, sf reflect.StructField, directive string) (structs.Applier, gomerr.Gomerr) {\n\tif directive == skipField || (directive == \"\" && ap.emptyDirective == skipField) {\n\t\treturn nil, nil\n\t}\n\n\tif applier, ge := structs.Composite(directive, ap.tool, st, sf); applier != nil || ge != nil {\n\t\treturn applier, ge\n\t}\n\n\tif directive == includeField || directive == \"\" { // b.emptyDirective must be 'includeField' otherwise would have returned above\n\t\treturn inApplier{(*ap.toCase)(sf.Name), ap.tool}, nil\n\t} else if firstChar := directive[0]; firstChar == '=' {\n\t\treturn structs.ValueApplier{directive[1:]}, nil // don't include the '='\n\t} else if firstChar == '$' {\n\t\treturn structs.ExpressionApplierProvider(st, sf, directive)\n\t}\n\n\tif ap.extension != nil {\n\t\tif applier, ge := ap.extension.Applier(st, sf, directive); applier != nil || ge != nil {\n\t\t\treturn applier, ge\n\t\t}\n\t}\n\n\treturn inApplier{(*ap.toCase)(directive), ap.tool}, nil\n}\n",
      "kind": 2,
      "metadata": {
        "id": 4,
        "type": "originalCode",
        "lineNumberBase": 40
      }
    },
    {
      "outputs": [],
      "languageId": "go",
      "id": "5",
      "value": "\ntype inApplier struct {\n\tsource string\n\ttool   *structs.Tool\n}\n",
      "kind": 2,
      "metadata": {
        "id": 5,
        "type": "originalCode",
        "lineNumberBase": 66
      }
    },
    {
      "outputs": [],
      "languageId": "go",
      "id": "6",
      "value": "\nvar (\n\ttimeType      = reflect.TypeOf((*time.Time)(nil)).Elem()\n\tbyteSliceType = reflect.TypeOf((*[]uint8)(nil)).Elem()\n\t// uint8SliceType = reflect.TypeOf((*[]uint8)(nil)).Elem()\n)\n\nfunc (a inApplier) Apply(sv reflect.Value, fv reflect.Value, tc *structs.ToolContext) gomerr.Gomerr {\n\tinData := tc.Get(InKey)\n\tif inData == nil {\n\t\treturn nil\n\t}\n\n\timv := reflect.ValueOf(inData)\n\tif imv.Kind() != reflect.Map {\n\t\treturn gomerr.Unprocessable(\"Expected data map\", inData).AddAttribute(\"Source\", a.source)\n\t}\n\n\tmv := imv.MapIndex(reflect.ValueOf(a.source))\n\tif !mv.IsValid() || mv.IsNil() {\n\t\treturn nil\n\t}\n\tvalue := mv.Interface()\n\n\tswitch fvt := fv.Type(); fv.Kind() {\n\tcase reflect.Struct:\n\t\tvt := reflect.TypeOf(value)\n\n\t\t// Time structs are a special case\n\t\tif stringValue, ok := value.(string); ok && fvt == timeType {\n\t\t\tt, err := time.Parse(time.RFC3339Nano, stringValue)\n\t\t\tif err != nil {\n\t\t\t\treturn gomerr.BadValue(gomerr.GenericBadValueType, a.source, stringValue).AddAttribute(\"Expected\", \"RFC3339-formatted string\")\n\t\t\t}\n\t\t\tfv.Set(reflect.ValueOf(t)) // TODO: use flect.SetValue instead?\n\t\t\treturn nil\n\t\t} else if fvt == vt {\n\t\t\treturn flect.SetValue(fv, value)\n\t\t}\n\n\t\tif vt.Kind() != reflect.Map {\n\t\t\treturn gomerr.Unprocessable(\"Expected data map\", value).AddAttribute(\"Source\", a.source)\n\t\t}\n\n\t\ttc.Put(InKey, value)\n\t\tdefer tc.Put(InKey, inData)\n\t\tif ge := structs.ApplyTools(fv, tc, a.tool); ge != nil {\n\t\t\treturn ge.AddAttribute(\"Source\", a.source)\n\t\t}\n\tcase reflect.Slice:\n\t\t// []byte types are a special case\n\t\t// TODO: should treat other primitive types this way?\n\t\tif fvt == byteSliceType {\n\t\t\tif _, ok := value.(string); ok {\n\t\t\t\tif ge := flect.SetValue(fv, value); ge != nil {\n\t\t\t\t\treturn ge.AddAttributes(\"Source\", a.source)\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t} // TODO:p2 treat the rest as raw input data - but may have already been exploded depending on how the rest of the data has been handled\n\t\t}\n\n\t\tsliceData, ok := value.([]interface{})\n\t\tif !ok {\n\n\t\t}\n\n\t\tsliceLen := len(sliceData)\n\t\tfv.Set(reflect.MakeSlice(reflect.SliceOf(fvt.Elem()), sliceLen, sliceLen))\n\n\t\t// Putting each element of the slice into a map so the a.Apply() call can fetch the data back out. Allows us\n\t\t// to easily support complex slice elem types.\n\t\tdefer tc.Put(InKey, inData)\n\t\tfor i := 0; i < sliceLen; i++ {\n\t\t\ttc.Put(InKey, map[string]interface{}{a.source: sliceData[i]})\n\t\t\tif ge := a.Apply(sv, fv.Index(i), tc); ge != nil {\n\t\t\t\treturn ge.AddAttribute(\"Index\", i)\n\t\t\t}\n\t\t}\n\tcase reflect.Map:\n\t\tfv.Set(reflect.MakeMap(fvt))\n\n\t\titer := reflect.ValueOf(value).MapRange() // Unsure why this needs to be reflected again...\n\t\tdefer tc.Put(InKey, inData)\n\t\tfor iter.Next() {\n\t\t\ttc.Put(InKey, map[string]interface{}{a.source: iter.Value().Interface()})\n\t\t\tmapElem := reflect.New(fvt.Elem()).Elem()\n\t\t\tif ge := a.Apply(sv, mapElem, tc); ge != nil {\n\t\t\t\treturn ge.AddAttribute(\"Key\", iter.Key().String())\n\t\t\t}\n\t\t\tfv.SetMapIndex(iter.Key(), mapElem)\n\t\t}\n\t\ttc.Put(InKey, inData)\n\tcase reflect.Ptr:\n\t\telemKind := fvt.Elem().Kind()\n\t\tif elemKind == reflect.Struct || elemKind == reflect.Slice || elemKind == reflect.Map || elemKind == reflect.Ptr {\n\t\t\tif fv.IsNil() {\n\t\t\t\tfv.Set(reflect.New(fvt.Elem()))\n\t\t\t}\n\t\t\t// No need to update toolContext\n\t\t\treturn a.Apply(sv, fv.Elem(), tc)\n\t\t}\n\t\tfallthrough\n\tdefault:\n\t\tif ge := flect.SetValue(fv, value); ge != nil {\n\t\t\treturn ge.AddAttributes(\"Source\", a.source)\n\t\t}\n\t}\n\n\treturn nil\n}\n",
      "kind": 2,
      "metadata": {
        "id": 6,
        "type": "originalCode",
        "lineNumberBase": 71
      }
    }
  ],
  "metadata": {
    "defaultDir": ".boost",
    "sourceFile": "./bind/intool.go"
  }
}